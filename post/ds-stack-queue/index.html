<html>
<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />

<title>栈与队列 | 光溯星河的复习笔记</title>

<link rel="shortcut icon" href="https://timestarry.github.io/favicon.ico?v=1729859530611">

<link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://timestarry.github.io/styles/main.css">
<!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css"> -->

<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/9.12.0/languages/dockerfile.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/9.12.0/languages//dart.min.js"></script>

<!-- <script src="https://cdn.jsdelivr.net/npm/moment@2.27.0/moment.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/js/bootstrap.min.js"></script> -->
<!-- DEMO JS -->
<!--<script src="media/scripts/index.js"></script>-->



    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.css">
    
</head>
<body>
<div class="main gt-bg-theme-color-first">
    <nav class="navbar navbar-expand-lg">
    <a class="navbar-brand" href="/">
        <img class="user-avatar" src="/images/avatar.png" alt="头像">
        <div class="site-name gt-c-content-color-first">
            光溯星河的复习笔记
        </div>
    </a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
        aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation" id="changeNavbar">
        <i class="fas fa-bars gt-c-content-color-first" style="font-size: 18px"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <div class="navbar-nav mr-auto" style="text-align: center">
            
            <div class="nav-item">
                
                <a href="https://blog.tsio.top" class="menu gt-a-link" target="_blank">
                    博客主站✈
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/tag/model_cpp" class="menu gt-a-link">
                    C++
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/tag/os" class="menu gt-a-link">
                    操作系统
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/tag/model_algo" class="menu gt-a-link">
                    数据结构与算法
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/tag/model_net" class="menu gt-a-link">
                    网络
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/tag/model_db" class="menu gt-a-link">
                    数据库
                </a>
                
            </div>
            
        </div>
        <div style="text-align: center">
            <form id="gridea-search-form" style="position: relative" data-update="1729859530611"
                action="/search/">
                <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
                <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
        </div>
    </div>
</nav>
<script>
    /* 移动端导航栏展开/收起切换 */
    document.getElementById('changeNavbar').onclick = () => {
        var element = document.getElementById('navbarSupportedContent');
        if (element.style.display === 'none' || element.style.display === '') {
            element.style.display = 'block';
        } else {
            element.style.display = 'none';
        }
    }
</script>

    <div class="post-container">
        <div class="post-detail gt-bg-theme-color-second">
            <article class="gt-post-content">
                <h2 class="post-title">
                    栈与队列
                </h2>
                <div class="post-info">
                    <time class="post-time gt-c-content-color-first">
                        · 2024-10-23 ·
                    </time>
                    
                        <a href="https://timestarry.github.io/tag/model_algo/" class="post-tags">
                            # 数据结构与算法
                        </a>
                    
                </div>
                <div class="post-content">
                    <h1 id="栈">栈</h1>
<p>栈（Stack）是先进后出的数据结构，我们可以将其想象为一个杯子，入栈就是不断往杯子中放入大小合适的小球，出栈时需要将小球从上至下一个个取出。</p>
<p>由此带来的访问入栈（push）、栈顶元素（top）、弹出栈顶（pop）时间复杂度都是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>.</p>
<h2 id="栈的常见应用场景">栈的常见应用场景</h2>
<ul>
<li>程序内存管理：函数栈，用于记录函数的上下文信息；</li>
<li>撤销与重做：撤销操作时将操作入栈，重做时将撤销的操作一个个出栈。</li>
</ul>
<h2 id="栈的两种实现方式">栈的两种实现方式</h2>
<p>我们可以使用数组或链表来实现栈，两种实现方式可以完成的栈功能都是一致的，但由于两种基本数据结构特性的不同，在部分操作的性能上存在差异。</p>
<p>使用数组实现时，为避免手动处理扩容问题，应使用动态数组实现。</p>
<p>两种实现方式的简单对比：</p>
<table>
<thead>
<tr>
<th></th>
<th>数组实现（数组尾部作栈顶）</th>
<th>链表实现（链表头节点作栈顶）</th>
</tr>
</thead>
<tbody>
<tr>
<td>入栈（<code>push</code>）</td>
<td>添加尾部元素（<code>push_back</code>）</td>
<td>添加头节点（<code>new-&gt;next = head;head = new-&gt;next</code>）</td>
</tr>
<tr>
<td>访问栈顶（<code>top</code>）</td>
<td>访问尾部元素（<code>back</code>）</td>
<td>访问头节点（<code>head-&gt;val</code>）</td>
</tr>
<tr>
<td>出栈（<code>pop</code>）</td>
<td>删除尾部元素（<code>pop_back</code>）</td>
<td>删除头节点（<code>head = head-&gt;next;delete</code>）</td>
</tr>
<tr>
<td>时间效率</td>
<td>出入栈操作涉及到的内存均已预先分配，操作效率较高；但入栈时若超出数组容量会触发数组扩容，导致该次入栈操作时间复杂度变为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，不过由于扩容是低频操作，平均效率较高。</td>
<td>链表不存在数组扩容的问题，但元素入栈需要初始化节点对象并修改指针，效率较低，若入栈元素本身就是节点对象则可省去初始化操作，提高效率。平均效率表现更稳定。</td>
</tr>
<tr>
<td>空间效率</td>
<td>初始化数组的空间可能是超出需求的，扩容机制按2倍或其它倍率扩容时也可能导致过多的空间浪费。</td>
<td>链表节点需要额外存储指针。两者具体空间效率要具体情况具体分析。</td>
</tr>
</tbody>
</table>
<h2 id="stl-stack">STL stack</h2>
<p>C++STL stack容器提供如下操作：</p>
<table>
<thead>
<tr>
<th>STL 函数</th>
<th>描述</th>
<th>操作时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>empty()</td>
<td>判断栈是否为空</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>size()</td>
<td>返回栈中元素的个数</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>top()</td>
<td>返回栈顶元素</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>push(element)</td>
<td>将元素压入栈顶</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>pop()</td>
<td>弹出栈顶元素</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td>
</tr>
</tbody>
</table>
<h1 id="队列">队列</h1>
<p>队列（Queue）是先进先出的数据结构，如同排队一样，我更喜欢将其想象为两端开口的管道，入队便是向管道入口放入小球，出队便是从管道出口取出小球，管道两端分别是只允许入或出的队尾和队首。</p>
<p>由此带来的入队（push）、访问队首（front）、出队（pop）时间复杂度均为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>.</p>
<h2 id="队列的常见应用场景">队列的常见应用场景</h2>
<ul>
<li>进程调度：例如，就绪队列中存储着处于就绪状态等待被调度执行的进程，当 CPU 空闲时，操作系统从就绪队列中选择一个进程进行执行；</li>
<li>消息队列：在分布式 Web 服务架构中，不同的服务组件之间可以通过消息队列进行通信。例如，订单服务在处理完一个订单后，可以将订单处理完成的消息放入消息队列。</li>
</ul>
<h2 id="队列的两种实现方式">队列的两种实现方式</h2>
<p>使用链表实现队列的思路比较常规，初始化头（front）尾（rear）节点，指向队列的头尾，并且规定队尾仅可添加，队首仅可删除，记录出入队记录队列长度（size）即可。</p>
<p>但<em><strong>Hello-algo</strong></em>中使用数组实现就比较妙了，它采用的方式是<strong>环形数组</strong>，所以这里着重讲一下环形数组实现队列的方法。示例实现这一方法时采用了<code>queCapacity</code>描述队列容量，即数组上限，当然也可采用动态数组的形式进行扩容。</p>
<h3 id="环形数组实现队列">环形数组实现队列</h3>
<p>使用数组实现队列时需要考虑解决这两个问题：</p>
<ul>
<li>在数组中删除首元素的时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>（删除并移动元素），可以使用队首指针front和长度size对队列有效范围进行规定，然后定义队尾<code>rear = front + size</code>，如此数组中队列的有效区间便为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>f</mi><mi>r</mi><mi>o</mi><mi>n</mi><mi>t</mi><mo separator="true">,</mo><mi>r</mi><mi>e</mi><mi>a</mi><mi>r</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">[front, rear - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>；</li>
<li>在不断的出入队过程中，front和rear移动到数组的尾部时将无法继续移动，解决方案是将数组视为首尾相接的<strong>环形数组</strong>。具体操作是让front或rear越过数组尾部时回到数组头部继续遍历，方法是取余。</li>
</ul>
<pre><code class="language-cpp">// 基于环形数组实现的队列
class ArrayQueue {
private:
    int* nums;       // 用于存储队列元素的数组
    int front;       // 队首指针，指向队首元素
    int queSize;     // 队列长度
    int queCapacity; // 队列容量

public:
    ArrayQueue(int capacity) {
        // 初始化队列
        nums = new int[capacity];
        front = 0;
        queSize = 0;
        queCapacity = capacity;
    }

    ~ArrayQueue() {
        delete[] nums;
    }

    // 队列容量
    int capacity() {
        return queCapacity;
    }

    // 队列大小
    int size() {
        return queSize;
    }

    // 队列是否为空
    bool empty() {
        if (queSize == 0) return true;
        else return false;
    }

    // 访问队首
    int front() {
        if (empty()) {
            std::cout &lt;&lt; &quot;队列为空&quot; &lt;&lt; std::endl;
            return;
        }
        return nums[front];
    }

    // 访问队尾
    int back() {
        if (empty()) {
            std::cout &lt;&lt; &quot;队列为空&quot; &lt;&lt; std::endl;
            return;
        }
        return nums[front + queSize - 1];
    }

    // 入队
    void push(int num) {
        if (queSize == queCapacity) {
            std::cout &lt;&lt; &quot;队列已满&quot; &lt;&lt; std::endl;
            return;
        }

        int rear = (front + queSize) % queCapacity; // 取余：rear越过数组尾部回到头部
        nums[rear] = num;
        queSize++;
    }

    // 出队
    int pop() {
        if (empty()) {
            std::cout &lt;&lt; &quot;队列为空&quot; &lt;&lt; std::endl;
            return;
        }

        front = (front + 1) % queCapacity;	// 取余：front越过数组尾部回到头部
        queSize--;
    }
};
</code></pre>
<h2 id="stl-queue">STL queue</h2>
<p>C++ STL queue容器提供如下操作：</p>
<table>
<thead>
<tr>
<th>STL 函数</th>
<th>描述</th>
<th>操作时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>empty()</td>
<td>判断队列是否为空</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>size()</td>
<td>返回队列中元素的个数</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>front()</td>
<td>返回队首元素</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>back()</td>
<td>返回队尾元素</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>push(element)</td>
<td>将元素压入队尾</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>pop()</td>
<td>弹出队首元素。</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td>
</tr>
</tbody>
</table>
<h1 id="双向队列">双向队列</h1>
<p>不同于队列仅允许单进单出，双向队列（double-ended queue）允许在头部和尾部执行添加或删除操作，提供了更高的灵活性。</p>
<p>双向队列支持在队列的两端执行常数级别的增删操作，即时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>.</p>
<h2 id="双向队列常见应用场景">双向队列常见应用场景</h2>
<ul>
<li>滑动窗口算法：例如，在求解数组中连续子数组的最大和问题时，可以使用双向队列来存储当前窗口内的元素，通过不断地调整窗口的大小和更新队列中的元素，找到最大的子数组和；</li>
<li>设定上限的撤销与重做：考虑到系统资源限制，软件的撤销步数通常是有上限的，即软件需要在撤销队列的最底部（队首、栈底）删除最远的步数，但栈无法做到这一操作，这时便可以使用双向队列替代栈。</li>
</ul>
<h2 id="双向队列的两种实现方式">双向队列的两种实现方式</h2>
<p>对应地，双向队列可以使用双向链表进行实现，在两端同时设计添加和删除节点功能。</p>
<p>数组实现则可参考队列的环形数组实现方案，在单向队列的基础上增加头节点（队尾）的删除和尾节点（队首）的添加功能。</p>
<h2 id="stl-deque">STL deque</h2>
<p>C++ STL deque容器提供如下操作：</p>
<table>
<thead>
<tr>
<th>STL 函数</th>
<th>描述</th>
<th>操作时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>empty()</td>
<td>判断双向队列是否为空</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>size()</td>
<td>返回双向队列中元素的个数</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>front()</td>
<td>返回双向队列的第一个元素的引用</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>back()</td>
<td>返回双向队列的最后一个元素的引用</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>push_front(element)</td>
<td>在双向队列的头部插入元素</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>push_back(element)</td>
<td>在双向队列的尾部插入元素</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>pop_front()</td>
<td>删除双向队列的第一个元素</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td>pop_back()</td>
<td>删除双向队列的最后一个元素</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td>
</tr>
</tbody>
</table>

                </div>
            </article>
        </div>

        
            <div class="next-post">
                <div class="next gt-c-content-color-first">下一篇</div>
                <a href="https://timestarry.github.io/post/ds-linklist/" class="post-title gt-a-link">
                    链表
                </a>
            </div>
        

        

        

        

        <div class="site-footer gt-c-content-color-first">
    <div class="slogan gt-c-content-color-first">温故而知新</div>
    <div class="social-container">
        
            
        
            
        
            
        
            
        
            
        
            
        
    </div>
    <div class="footer-info">
        <p>© <a href="https://blog.tsio.top/about">光溯星河</a> 2024 <a href="/post/about">关于</a></p>
    </div>
    <div>
        Theme <a href="https://github.com/imhanjie/gridea-theme-pure" target="_blank">Pure</a>, Powered by <a
                href="https://gridea.dev" target="_blank">Gridea</a> | <a href="https://timestarry.github.io/atom.xml" target="_blank">RSS</a>
    </div>
</div>

<script>
  hljs.highlightAll()
</script>

    </div>
</div>
</body>
</html>
